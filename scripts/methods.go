package main

import (
	"fmt"
	"strings"
	"text/template"
)

var (
	readerBranchTmpl                = template.Must(template.New("readerBranch").Parse(readerBranch))
	stringOrReaderBranchTmpl        = template.Must(template.New("stringOrReaderBranch").Parse(stringOrReaderBranch))
	inputMediaParamsBranchTmpl      = template.Must(template.New("inputMediaParamsBranch").Parse(inputMediaParamsBranch))
	inputMediaArrayParamsBranchTmpl = template.Must(template.New("inputMediaArrayParamsBranch").Parse(inputMediaArrayParamsBranch))
)

func generateMethods(d APIDescription) error {
	file := strings.Builder{}
	file.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gen

import (
	urlLib "net/url" // renamed to avoid clashes with url vars
	"encoding/json"
	"strconv"
	"fmt"
	"io"
)
`)

	for _, tgMethodName := range orderedMethods(d) {
		tgMethod := d.Methods[tgMethodName]
		method, err := generateMethodDef(d, tgMethod)
		if err != nil {
			return fmt.Errorf("failed to generate method definition of %s: %w", tgMethodName, err)
		}
		file.WriteString(method)
	}

	return writeGenToFile(file, "gen/gen_methods.go")
}

func generateMethodDef(d APIDescription, tgMethod MethodDescription) (string, error) {
	method := strings.Builder{}

	retType, err := tgMethod.GetReturnType(d)
	if err != nil {
		return "", fmt.Errorf("failed to get return for %s: %w", tgMethod.Name, err)
	}
	defaultRetVal := getDefaultReturnVal(retType)

	args, optionalsStruct, err := tgMethod.getArgs()
	if err != nil {
		return "", fmt.Errorf("failed to get args for method %s: %w", tgMethod.Name, err)
	}

	if optionalsStruct != "" {
		method.WriteString("\n" + optionalsStruct)
	}

	for _, d := range tgMethod.Description {
		method.WriteString("\n// " + d)
	}
	method.WriteString("\n// " + tgMethod.Href)

	method.WriteString("\nfunc (bot Bot) " + strings.Title(tgMethod.Name) + "(" + args + ") (" + retType + ", error) {")

	valueGen, hasData, err := tgMethod.argsToValues(defaultRetVal)
	if err != nil {
		return "", fmt.Errorf("failed to generate url values for method %s: %w", tgMethod.Name, err)
	}

	method.WriteString("\n	v := urlLib.Values{}")
	if hasData {
		method.WriteString("\n	data := map[string]NamedReader{}")
	}

	method.WriteString(valueGen)
	method.WriteString("\n")

	if hasData {
		method.WriteString("\nr, err := bot.Post(\"" + tgMethod.Name + "\", v, data)")
	} else {
		method.WriteString("\nr, err := bot.Get(\"" + tgMethod.Name + "\", v)")
	}
	method.WriteString("\n	if err != nil {")
	method.WriteString("\n		return " + defaultRetVal + ", err")
	method.WriteString("\n	}")
	method.WriteString("\n")

	retVarType := retType
	retVarName := getRetVarName(retVarType)
	isPointer := strings.HasPrefix(retVarType, "*")
	addr := ""
	if isPointer {
		retVarType = strings.TrimLeft(retVarType, "*")
		addr = "&"
	}
	method.WriteString("\nvar " + retVarName + " " + retVarType)
	method.WriteString("\nreturn " + addr + retVarName + ", json.Unmarshal(r, &" + retVarName + ")")
	method.WriteString("\n}")

	return method.String(), nil
}

func (m MethodDescription) argsToValues(defaultRetVal string) (string, bool, error) {
	hasData := false
	bd := strings.Builder{}
	for _, f := range m.Fields {
		goParam := snakeToCamel(f.Name)
		if !f.Required {
			goParam = "opts." + snakeToTitle(f.Name)
		}

		fieldType, err := f.getPreferredType()
		if err != nil {
			return "", false, fmt.Errorf("failed to get preferred type: %w", err)
		}
		stringer := goTypeStringer(toGoType(fieldType))
		if stringer != "" {
			bd.WriteString("\nv.Add(\"" + f.Name + "\", " + fmt.Sprintf(stringer, goParam) + ")")
			continue
		}

		switch fieldType {
		case "InputFile":
			hasData = true

			t := stringOrReaderBranchTmpl
			if len(f.Types) == 1 {
				// This is actually just an inputfile, not "InputFile or String", so don't support string
				t = readerBranchTmpl
			}

			err = t.Execute(&bd, readerBranchesData{
				GoParam:       goParam,
				DefaultReturn: defaultRetVal,
				Name:          f.Name,
			})
			if err != nil {
				return "", false, fmt.Errorf("failed to execute branch reader template: %w", err)
			}

		case "InputMedia":
			hasData = true

			err = inputMediaParamsBranchTmpl.Execute(&bd, readerBranchesData{
				GoParam:       goParam,
				DefaultReturn: defaultRetVal,
				Name:          f.Name,
			})
			if err != nil {
				return "", false, fmt.Errorf("failed to execute inputmedia branch template: %w", err)
			}

		case "Array of InputMedia":
			hasData = true

			err = inputMediaArrayParamsBranchTmpl.Execute(&bd, readerBranchesData{
				GoParam:       goParam,
				DefaultReturn: defaultRetVal,
				Name:          f.Name,
			})
			if err != nil {
				return "", false, fmt.Errorf("failed to execute inputmedia array branch template: %w", err)
			}

		case "ReplyMarkup":
			bd.WriteString("\n	bytes, err := " + goParam + ".ReplyMarkup()")
			bd.WriteString("\n	if err != nil {")
			bd.WriteString("\n		return " + defaultRetVal + ", fmt.Errorf(\"failed to marshal field " + f.Name + ": %w\", err)")
			bd.WriteString("\n	}")
			bd.WriteString("\n	v.Add(\"" + f.Name + "\", string(bytes))")

		default:
			if isTgArray(fieldType) {
				bd.WriteString("\nif " + goParam + " != nil {")
			}

			bd.WriteString("\n	bytes, err := json.Marshal(" + goParam + ")")
			bd.WriteString("\n	if err != nil {")
			bd.WriteString("\n		return " + defaultRetVal + ", fmt.Errorf(\"failed to marshal field " + f.Name + ": %w\", err)")
			bd.WriteString("\n	}")
			bd.WriteString("\n	v.Add(\"" + f.Name + "\", string(bytes))")

			if isTgArray(fieldType) {
				bd.WriteString("\n}")
			}
		}
	}

	return bd.String(), hasData, nil
}

func getRetVarName(retType string) string {
	for strings.HasPrefix(retType, "*") {
		retType = strings.TrimPrefix(retType, "*")
	}
	for strings.HasPrefix(retType, "[]") {
		retType = strings.TrimPrefix(retType, "[]")
	}
	return strings.ToLower(retType[:1])
}

func (m MethodDescription) getArgs() (string, string, error) {
	var requiredArgs []string
	optionals := strings.Builder{}
	for _, f := range m.Fields {
		fieldType, err := f.getPreferredType()
		if err != nil {
			return "", "", fmt.Errorf("failed to get preferred type: %w", err)
		}
		goType := toGoType(fieldType)
		if f.Required {
			requiredArgs = append(requiredArgs, fmt.Sprintf("%s %s", snakeToCamel(f.Name), goType))
			continue
		}

		optionals.WriteString("\n// " + f.Description)
		optionals.WriteString("\n" + fmt.Sprintf("%s %s", snakeToTitle(f.Name), goType))

	}
	optionalsStruct := ""

	if optionals.Len() > 0 {
		optionalsName := m.optsName()
		bd := strings.Builder{}
		bd.WriteString("\ntype " + optionalsName + " struct {")
		bd.WriteString(optionals.String())
		bd.WriteString("\n}")
		optionalsStruct = bd.String()

		requiredArgs = append(requiredArgs, fmt.Sprintf("opts %s", optionalsName))
	}

	return strings.Join(requiredArgs, ", "), optionalsStruct, nil
}

type readerBranchesData struct {
	GoParam       string
	DefaultReturn string
	Name          string
}

const readerBranch = `
if {{.GoParam}} != nil {
	if r, ok := {{.GoParam}}.(io.Reader); ok {
		v.Add("{{.Name}}", "attach://{{.Name}}")
		data["{{.Name}}"] = NamedReader{File: r}
	} else if nf, ok := {{.GoParam}}.(NamedReader); ok {
		v.Add("{{.Name}}", "attach://{{.Name}}")
		data["{{.Name}}"] = nf
	} else {
		return {{.DefaultReturn}}, fmt.Errorf("unknown type for InputFile: %T",{{.GoParam}})
	}
}
`

const stringOrReaderBranch = `
if {{.GoParam}} != nil {
	if s, ok := {{.GoParam}}.(string); ok {
		v.Add("{{.Name}}", s)
	} else if r, ok := {{.GoParam}}.(io.Reader); ok {
		v.Add("{{.Name}}", "attach://{{.Name}}")
		data["{{.Name}}"] = NamedReader{File: r}
	} else if nf, ok := {{.GoParam}}.(NamedReader); ok {
		v.Add("{{.Name}}", "attach://{{.Name}}")
		data["{{.Name}}"] = nf
	} else {
		return {{.DefaultReturn}}, fmt.Errorf("unknown type for InputFile: %T",{{.GoParam}})
	}
}
`

const inputMediaParamsBranch = `
inputMediaBs, err := {{.GoParam}}.InputMediaParams("{{.Name}}" , data)
if err != nil {
	return {{.DefaultReturn}}, fmt.Errorf("failed to marshal field {{.Name}}: %w", err)
}
v.Add("{{.Name}}", string(inputMediaBs))
`

const inputMediaArrayParamsBranch = `
if {{.GoParam}} != nil {
	var rawList []json.RawMessage
	for idx, im := range {{.GoParam}} {
		inputMediaBs, err := im.InputMediaParams("{{.Name}}" + strconv.Itoa(idx), data)
		if err != nil {
			return {{.DefaultReturn}}, fmt.Errorf("failed to marshal InputMedia list item %d for field {{.Name}}: %w", idx, err)
		}
		rawList = append(rawList, inputMediaBs)
	}
	bytes, err := json.Marshal(rawList)
	if err != nil {
		return {{.DefaultReturn}}, fmt.Errorf("failed to marshal raw json list of InputMedia for field: {{.Name}} %w", err)
	}
	v.Add("{{.Name}}", string(bytes))
}
`
