package main

import (
	"fmt"
	"sort"
	"strings"
)

// TODO: dont hardcode; obtain these from reply_markup fields
var replyMarkupTypes = []string{
	"InlineKeyboardMarkup",
	"ReplyKeyboardMarkup",
	"ReplyKeyboardRemove",
	"ForceReply",
}

func generateTypes(d APIDescription) error {
	file := strings.Builder{}
	file.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gen

import (
	"encoding/json"
	"fmt"
	"io"
)
`)

	// TODO: Obtain ordered map to retain tg ordering
	var types []string
	for k := range d.Types {
		types = append(types, k)
	}
	sort.Strings(types)

	for _, tgTypeName := range types {
		file.WriteString(generateTypeDef(d, tgTypeName))
	}

	file.WriteString("\ntype ReplyMarkup interface{")
	file.WriteString("\n	ReplyMarkup() ([]byte, error)")
	file.WriteString("\n}")

	return writeGenToFile(file, "gen/gen_types.go")
}

func generateTypeDef(d APIDescription, tgTypeName string) string {
	typeDef := strings.Builder{}
	tgType := d.Types[tgTypeName]

	for _, d := range tgType.Description {
		typeDef.WriteString("\n// " + d)
	}
	typeDef.WriteString("\n// " + tgType.Href)
	if len(tgType.Fields) == 0 {
		typeDef.WriteString("\ntype " + tgTypeName + " interface{")
		if len(tgType.Subtypes) != 0 {
			typeDef.WriteString("\n	" + tgTypeName + "Params(string, map[string]NamedReader) ([]byte, error)")
			typeDef.WriteString("\n")
		}
		typeDef.WriteString("}")

		return typeDef.String()
	}

	typeDef.WriteString("\ntype " + tgTypeName + " struct {")
	for _, f := range tgType.Fields {
		fieldType := getPreferredType(f)

		// InputMedia is a special one.
		if isSubtypeOf(tgType, "InputMedia") {
			// we don't write the type field since it isnt something that should be customised. This is set in the custom marshaller.
			if f.Name == "type" {
				continue
			}
			// We manually override the media field to have InputFile type on all inputmedia to allow reuse of fileuploads logic.
			if f.Name == "media" {
				fieldType = "InputFile"
			}
		}

		goType := toGoType(fieldType)
		if isTgType(d.Types, goType) && !f.Required {
			goType = "*" + goType
		}

		typeDef.WriteString("\n// " + f.Description)
		typeDef.WriteString("\n" + snakeToTitle(f.Name) + " " + goType + " `json:\"" + f.Name + ",omitempty\"`")
	}

	typeDef.WriteString("\n}")

	if strings.HasPrefix(tgTypeName, "InputMedia") {
		typeDef.WriteString("\n")
		typeDef.WriteString(genCustomMarshal(tgTypeName))
	}

	for _, parentType := range tgType.SubtypeOf {
		switch parentType {
		case "InputMedia":
			typeDef.WriteString("\n")
			typeDef.WriteString("\nfunc (v " + tgTypeName + ") " + parentType + "Params(mediaName string, data map[string]NamedReader) ([]byte, error) {")

			typeDef.WriteString(paramsReader)

			typeDef.WriteString("\n	return json.Marshal(v)")
			typeDef.WriteString("\n}")

		case "InputMessageContent", "InlineQueryResult", "PassportElementError":
			// TODO: Verify these. They should be ok, but should run more tests.
		default:
			fmt.Printf("Unable to handle parent type %s while generating for type %s\n", parentType, tgTypeName)
		}
	}

	for _, t := range replyMarkupTypes {
		if tgTypeName == t {
			typeDef.WriteString("\n")
			typeDef.WriteString("\nfunc (v " + tgTypeName + ") ReplyMarkup() ([]byte, error) {")
			typeDef.WriteString("\n	return json.Marshal(v)")
			typeDef.WriteString("\n}")
			break
		}
	}

	return typeDef.String()
}

func isSubtypeOf(tgType TypeDescription, parentType string) bool {
	for _, pt := range tgType.SubtypeOf {
		if parentType == pt {
			return true
		}
	}
	return false
}

func genCustomMarshal(name string) string {
	marshalDef := strings.Builder{}

	marshalDef.WriteString("\nfunc (v " + name + ") MarshalJSON() ([]byte, error) {")
	marshalDef.WriteString("\n	type alias " + name)
	marshalDef.WriteString("\n	a := struct{")
	marshalDef.WriteString("\n		Type string `json:\"type,omitempty\"`")
	marshalDef.WriteString("\n		alias")
	marshalDef.WriteString("\n	}{")
	marshalDef.WriteString("\n		Type: \"" + strings.ToLower(strings.TrimPrefix(name, "InputMedia")) + "\",")
	marshalDef.WriteString("\n		alias: (alias)(v),")
	marshalDef.WriteString("\n	}")
	marshalDef.WriteString("\nreturn json.Marshal(a)")
	marshalDef.WriteString("\n}")

	return marshalDef.String()
}

const paramsReader = `
if v.Media != nil {
	if r, ok := v.Media.(io.Reader); ok {
		v.Media = "attach://"+mediaName
		data[mediaName] = NamedReader{File: r}
	} else if nf, ok := v.Media.(NamedReader); ok {
		v.Media = "attach://"+mediaName
		data[mediaName] = nf
	} else {
		return nil, fmt.Errorf("unknown type for InputFile: %T", v.Media)
	}
}
`
