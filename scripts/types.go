package main

import (
	"fmt"
	"html/template"
	"sort"
	"strings"
)

// TODO: dont hardcode; obtain these from reply_markup fields
var replyMarkupTypes = []string{
	"InlineKeyboardMarkup",
	"ReplyKeyboardMarkup",
	"ReplyKeyboardRemove",
	"ForceReply",
}

var (
	replyMarkupMethodTmpl   = template.Must(template.New("replyMarkupMethod").Parse(replyMarkupInterfaceMethod))
	inputMediaInterfaceTmpl = template.Must(template.New("inputMediaInterface").Parse(inputMediaInterfaceMethod))
	customMarshalTmpl       = template.Must(template.New("customMarshal").Parse(customMarshal))
)

func generateTypes(d APIDescription) error {
	file := strings.Builder{}
	file.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gen

import (
	"encoding/json"
	"fmt"
	"io"
)
`)

	// TODO: Obtain ordered map to retain tg ordering
	var types []string
	for k := range d.Types {
		types = append(types, k)
	}
	sort.Strings(types)

	for _, tgTypeName := range types {
		tgType := d.Types[tgTypeName]
		typeDef, err := generateTypeDef(d, tgType)
		if err != nil {
			return fmt.Errorf("failed to generate type definition of %s: %w", tgTypeName, err)
		}
		file.WriteString(typeDef)
	}

	// the reply_markup field is weird; this allows it to support multiple types.
	file.WriteString(`
type ReplyMarkup interface{
	ReplyMarkup() ([]byte, error)
}`)

	return writeGenToFile(file, "gen/gen_types.go")
}

func generateTypeDef(d APIDescription, tgType TypeDescription) (string, error) {
	typeDef := strings.Builder{}

	for _, d := range tgType.Description {
		typeDef.WriteString("\n// " + d)
	}
	typeDef.WriteString("\n// " + tgType.Href)
	if len(tgType.Fields) == 0 {
		typeDef.WriteString(generateInputMediaInterfaceType(tgType.Name, tgType))
		return typeDef.String(), nil
	}

	typeDef.WriteString("\ntype " + tgType.Name + " struct {")
	for _, f := range tgType.Fields {
		fieldType, err := f.getPreferredType()
		if err != nil {
			return "", fmt.Errorf("failed to get preferred type: %w", err)
		}

		// InputMedia is a special one.
		if isSubtypeOf(tgType, "InputMedia") {
			// we don't write the type field since it isnt something that should be customised. This is set in the custom marshaller.
			if f.Name == "type" {
				continue
			}
			// We manually override the media field to have InputFile type on all inputmedia to allow reuse of fileuploads logic.
			if f.Name == "media" {
				fieldType = "InputFile"
			}
		}

		goType := toGoType(fieldType)
		if isTgType(d, goType) && !f.Required {
			goType = "*" + goType
		}

		typeDef.WriteString("\n// " + f.Description)
		typeDef.WriteString("\n" + snakeToTitle(f.Name) + " " + goType + " `json:\"" + f.Name + ",omitempty\"`")
	}

	typeDef.WriteString("\n}")

	for _, parentType := range tgType.SubtypeOf {
		switch parentType {
		case "InputMedia":
			// InputMedia items need a custom marshaller to handle the "type" field
			err := customMarshalTmpl.Execute(&typeDef, customMarshalData{
				Type:     tgType.Name,
				TypeName: strings.ToLower(strings.TrimPrefix(tgType.Name, "InputMedia")),
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate custom marshal function for %s: %w", tgType.Name, err)
			}

			// We also need to setup the interface method
			err = inputMediaInterfaceTmpl.Execute(&typeDef, inputMediaParamData{
				Type:       tgType.Name,
				ParentType: parentType,
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate inputmedia interface methods for %s: %w", tgType.Name, err)
			}

		case "InputMessageContent", "InlineQueryResult", "PassportElementError":
			// TODO: Verify these. They should be ok, but should run more tests.
		default:
			return "", fmt.Errorf("Unable to handle parent type %s while generating for type %s\n", parentType, tgType.Name)
		}
	}

	for _, t := range replyMarkupTypes {
		if tgType.Name == t {
			err := replyMarkupMethodTmpl.Execute(&typeDef, replyMarkupInterfaceData{
				Type: tgType.Name,
			})
			if err != nil {
				return "", fmt.Errorf("failed to generate replymarkup interface methods for %s: %w", tgType.Name, err)
			}

			break
		}
	}

	return typeDef.String(), nil
}

func generateInputMediaInterfaceType(name string, tgType TypeDescription) string {
	if len(tgType.Subtypes) != 0 {
		return fmt.Sprintf(`
type %s interface{
	%sParams(string, map[string]NamedReader) ([]byte, error)
}`, name, name)
	}
	return "\ntype " + name + " interface{}"
}

func isSubtypeOf(tgType TypeDescription, parentType string) bool {
	for _, pt := range tgType.SubtypeOf {
		if parentType == pt {
			return true
		}
	}
	return false
}

type customMarshalData struct {
	Type     string
	TypeName string
}

const customMarshal = `
func (v {{.Type}}) MarshalJSON() ([]byte, error) {
	type alias {{.Type}}
	a := struct{
		Type string
		alias
	}{
		Type: "{{.TypeName}}",
		alias: (alias)(v),
	}
	return json.Marshal(a)
}
`

type inputMediaParamData struct {
	Type       string
	ParentType string
}

const inputMediaInterfaceMethod = `
func (v {{.Type}}) {{.ParentType}}Params(mediaName string, data map[string]NamedReader) ([]byte, error) {
	if v.Media != nil {
		if r, ok := v.Media.(io.Reader); ok {
			v.Media = "attach://" + mediaName
			data[mediaName] = NamedReader{File: r}
		} else if nf, ok := v.Media.(NamedReader); ok {
			v.Media = "attach://" + mediaName
			data[mediaName] = nf
		} else {
			return nil, fmt.Errorf("unknown type for InputFile: %T", v.Media)
		}
	}
	
	return json.Marshal(v)
}
`

type replyMarkupInterfaceData struct {
	Type string
}

const replyMarkupInterfaceMethod = `
func (v {{.Type}}) ReplyMarkup() ([]byte, error) {
	return json.Marshal(v)
}
`
