package main

import (
	"fmt"
	"sort"
	"strings"
)

func generateTypes(d APIDescription) error {
	file := strings.Builder{}
	file.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gen

import (
	"encoding/json"
	"fmt"
	"io"
)
`)

	// TODO: Obtain ordered map to retain tg ordering
	var types []string
	for k := range d.Types {
		types = append(types, k)
	}
	sort.Strings(types)

	for _, tgTypeName := range types {
		file.WriteString(generateTypeDef(d, tgTypeName))
	}

	return writeGenToFile(file, "gen/gen_types.go")
}

func generateTypeDef(d APIDescription, tgTypeName string) string {
	typeDef := strings.Builder{}
	tgType := d.Types[tgTypeName]

	for _, d := range tgType.Description {
		typeDef.WriteString("\n// " + d)
	}
	typeDef.WriteString("\n// " + tgType.Href)
	if len(tgType.Fields) == 0 {
		// todo: Generate interface methods for child functions
		typeDef.WriteString("\ntype " + tgTypeName + " interface{")
		if len(tgType.Subtypes) != 0 {
			typeDef.WriteString("\n	" + tgTypeName + "Params(string, map[string]NamedReader) ([]byte, error)")
			typeDef.WriteString("\n")
		}
		typeDef.WriteString("}")

		return typeDef.String()
	}

	var genCustomMarshalFields []Field
	typeDef.WriteString("\ntype " + tgTypeName + " struct {")
	for _, field := range tgType.Fields {
		fieldType := field.Types[0] // TODO: NOT just default to first type

		// InputMedia is a special one.
		if isSubtypeOf(tgType, "InputMedia") {
			// we don't write the type field since it isnt something that should be customised. This is set in the custom marshaller.
			if field.Name == "type" {
				continue
			}
			// We manually override the media field to have InputFile type on all inputmedia to allow reuse of fileuploads logic.
			if field.Name == "media" {
				fieldType = "InputFile"
			}
		}

		goType := toGoTypes(fieldType)
		if isTgType(d.Types, goType) && !field.Required {
			goType = "*" + goType
		}

		if isTgArray(fieldType) {
			genCustomMarshalFields = append(genCustomMarshalFields, field)
		}

		typeDef.WriteString("\n// " + field.Description)
		typeDef.WriteString("\n" + snakeToTitle(field.Name) + " " + goType + " `json:\"" + field.Name + "\"`")
	}

	typeDef.WriteString("\n}")

	if len(genCustomMarshalFields) > 0 {
		typeDef.WriteString(genCustomMarshal(tgTypeName, genCustomMarshalFields))
	}

	for _, parentType := range tgType.SubtypeOf {
		switch parentType {
		case "InputMedia":
			typeDef.WriteString("\n")
			typeDef.WriteString("\nfunc (v " + tgTypeName + ") " + parentType + "Params(mediaName string, data map[string]NamedReader) ([]byte, error) {")

			typeDef.WriteString(paramsReader)

			typeDef.WriteString("\n	return json.Marshal(v)")
			typeDef.WriteString("\n}")

		case "InputMessageContent", "InlineQueryResult", "PassportElementError":
			// TODO: Verify these.
			// Should be ok, but got to run more tests.
		default:
			fmt.Printf("Unable to handle parent type %s while generating for type %s\n", parentType, tgTypeName)
		}
	}

	return typeDef.String()
}

func isSubtypeOf(tgType TypeDescription, parentType string) bool {
	for _, pt := range tgType.SubtypeOf {
		if parentType == pt {
			return true
		}
	}
	return false
}

func genCustomMarshal(name string, fields []Field) string {
	marshalDef := strings.Builder{}

	marshalDef.WriteString("\n")
	marshalDef.WriteString("\nfunc (v " + name + ") MarshalJSON() ([]byte, error) {")
	marshalDef.WriteString("\n	type alias " + name)
	marshalDef.WriteString("\n	a := struct{")
	if strings.HasPrefix(name, "InputMedia") {
		marshalDef.WriteString("\n		Type string `json:\"type\"`")
	}
	marshalDef.WriteString("\n		alias")
	marshalDef.WriteString("\n	}{")

	if strings.HasPrefix(name, "InputMedia") {
		marshalDef.WriteString("\n		Type: \"" + strings.ToLower(strings.TrimPrefix(name, "InputMedia")) + "\",")
	}
	marshalDef.WriteString("\n		alias: (alias)(v),")
	marshalDef.WriteString("\n	}")
	for _, f := range fields {
		marshalDef.WriteString("\n	if a." + snakeToTitle(f.Name) + " == nil {")
		marshalDef.WriteString("\n		a." + snakeToTitle(f.Name) + " = make(" + toGoTypes(f.Types[0]) + ", 0)")
		marshalDef.WriteString("\n	}")
	}
	marshalDef.WriteString("\nreturn json.Marshal(a)")
	marshalDef.WriteString("\n}")

	return marshalDef.String()
}

const paramsReader = `
if v.Media != nil {
	if r, ok := v.Media.(io.Reader); ok {
		v.Media = "attach://"+mediaName
		data[mediaName] = NamedReader{File: r}
	} else if nf, ok := v.Media.(NamedReader); ok {
		v.Media = "attach://"+mediaName
		data[mediaName] = nf
	} else {
		return nil, fmt.Errorf("unknown type for InputFile: %T", v.Media)
	}
}
`
